#!/usr/bin/python
#-*- coding: utf-8 -*-
import sys, getopt, re


class AddSerialToCode:

    def __init__(self, input_file, output_file, address, models):
        '''
            Initialize AddSerialToCode object
            @param input_file file to be read
            @param output_file file to write the new code
        '''
        super(AddSerialToCode,self).__init__()
        print("AddSerialToCode")

        self.input_file    = input_file
        self.output_file   = output_file
        self.model_name    = ""
        self.input_events  = []
        self.output_events = []
        self.outputs       = []
        self.DIGITAL_PORTS = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
        self.TAB           = "    "
        self.addresses     = []
        self.strings = {}
        self.this_address = address
        self.models = models

    def write(self):
        '''
            Write the SoftwareSerial communication code to the output file
        '''
        print(self.input_file)
        print(self.output_file)
        try:
            print(self.input_file)
            print(self.output_file)
            # open input file to read and output file to append
            f_read  = open(self.input_file, 'r')
            f_write = open(self.output_file, 'w')
            # get the number of places, events and signals and go to the start of the file
            self.get_file_data(f_read.read())
            self.ask_for_addresses()
            f_write.write('/* Net ' + self.model_name + ' - IOPT */\n'
                               '/* Automatic code generated by IOPT2C XSLT transformation. */\n'
                               '/* Changed by IOPT2AC to run in Arduino */\n'
                               '/* Please fill the necessary code to perform hardware IO. */\n\n'
                               '#include <stdlib.h>\n#include "net_types.h"\n\n#include <Arduino.h>\n#define ANALOG_IN_MAX  1023\n'
                               '#define ANALOG_OUT_MAX 255\n\n//PYTHON - Initializations\n#include <Wire.h>\n')
            f_write.write('#define I2C_ADDRESS_ME ' + self.this_address + '\n' +
                                  self.get_init_addresses_string() +
                                  'String readString;\n' +
                                  self.get_events_flags_str() +
                                  '//PYTHON - End Initializations\n\n')

            f_write.write('//PYTHON - Receive Listener Function\n' +
                                  'void receiveI2C(int num) {\n' +
                                  self.TAB + 'readString = "";\n'+
                                  self.TAB + 'while (Wire.available() > 0) {\n' +
                                  self.TAB + self.TAB +  'delay(4);\n' +
                                  self.TAB + self.TAB + 'char c = Wire.read();\n' +
                                  self.TAB + self.TAB + 'readString += c;\n' + self.TAB + '}\n' +
                                  self.get_receive_string_verification() +
                                  '\n}\n//PYTHON - End Listener Function\n\n')

            f_write.write('/* Executed just once, before net execution starts: */\n' +
                          'void ' + self.model_name + '_InitializeIO()\n{\n')
            f_write.write(self.TAB + '//PYTHON - Initialize digital outputs\n')
            for k in range(len(self.DIGITAL_PORTS)):
                f_write.write(self.TAB + 'pinMode(' + str(self.DIGITAL_PORTS[k]) + ', OUTPUT);\n')
                f_write.write(self.TAB + 'digitalWrite(' + str(self.DIGITAL_PORTS[k]) + ', LOW);\n')
            f_write.write(self.TAB + '//PYTHON - Initialize serial and i2c communications\n' +
                                  self.TAB + 'Serial.begin(9600);\n' +
                                  self.TAB + 'Wire.begin(I2C_ADDRESS_ME);\n' +
                                  self.TAB + '//PYTHON - End serial and i2c initializations\n}\n\n')
            f_write.write(self.get_inputs_places_string())
            f_write.write(self.get_event_flag_check_string())
            f_write.write('}\n\n')
            f_write.write(self.get_output_places_string())
            f_write.write(self.get_send_comm_string())
            f_write.write('}\n\n')
            f_write.write('/* Delay between loop iterations to save CPU and power consumption */\n' +
                          'void ' + self.model_name + '_LoopDelay()\n{\n' +
                           self.TAB + '//PYTHON - Loop config\n' +
                           self.TAB + 'delay(10);\n' +
                           self.TAB + 'Serial.println("Loop ' + str(self.this_address) + '");\n' +
                           self.TAB + 'Wire.onReceive(receiveI2C);\n' +
                           self.TAB + '//PYTHON - End loop config\n}\n\n')
            f_write.write('/* Must return 1 to finish net execution */\n' +
                          'int ' + self.model_name + '_FinishExecution( ' + self.model_name + '_NetMarking* marking )\n' +
                         '{\n' + self.TAB + 'return 0;\n' + '}')

        except IOError as e:
            print "I/O error({0}): {1}".format(e.errno, e.strerror)
        except ValueError:
            print "Could not convert data to an integer."
        except:
            print "Unexpected error:", sys.exc_info()[0]
            raise

    def get_init_addresses_string(self):
        string = ""
        for i in self.addresses:
            string += '#define I2C_ADDRESS_' + i['event'] + ' ' + i['address'] + '\n'
        return string



    def get_events_flags_str(self):
        string = ''
        for i in self.input_events:
            string += 'int ' + i + '_flag = 0;\n'
        return string

    def get_receive_string_verification(self):
        string = ''
        for i in self.input_events:
            string += self.TAB + 'if(readString == "' + i + '") {\n' +\
                       self.TAB + self.TAB + i + '_flag = 1;\n' +\
                        self.TAB + '}'
        return string

    def get_event_flag_check_string(self):
        string = self.TAB + 'if( events != NULL ) {\n'
        string += self.TAB + self.TAB + '// PYTHON - Change event state\n'
        for i in self.input_events:
            string += self.TAB + self.TAB + 'if (' + i + '_flag) {\n' +\
                      self.TAB + self.TAB + self.TAB + 'events->' + i + ' = 1;\n' +\
                      self.TAB + self.TAB + self.TAB + i + '_flag = 0;\n' +\
                      self.TAB + self.TAB + '} else {\n' +\
                      self.TAB + self.TAB + self.TAB + 'events->'+ i + ' = 0;\n' +\
                      self.TAB + self.TAB + '}\n'
        string += self.TAB + self.TAB + '//PYTHON - End change event state\n' + self.TAB + '}\n'
        return string

    def get_inputs_places_string(self):

        string = '/* Read all hardware input signals and fill data-structure */\n' +\
                 'void ' + self.model_name + '_GetInputSignals(\n' +\
                 self.TAB + self.model_name + '_InputSignals* inputs,\n' +\
                 self.TAB + self.model_name + '_InputSignalEvents* events )\n{\n'
        if len(self.inputs) == 0:
            string += self.TAB + '/* No Inputs*/\n\n'
        else:
            string += self.TAB + '//PYTHON - Digital read the inputs\n'
            for i, item in enumerate(self.inputs):
                string += self.TAB + 'inputs->' + item + ' = digitalRead(' + str(self.DIGITAL_PORTS[i]) + ');\n'
            string += self.TAB + '//PYTHON - End digital read the inputs\n'
        return string

    def get_output_places_string(self):
        string = '/* Write all output values to physical hardware outputs */\n' +\
                 'void ' + self.model_name + '_PutOutputSignals(\n' +\
                 self.TAB + self.model_name + '_PlaceOutputSignals* place_out,\n' +\
            self.TAB + self.model_name + '_EventOutputSignals* event_out,\n' +\
            self.TAB + self.model_name + '_OutputSignalEvents* events )\n{\n'
        if len(self.outputs) == 0:
            string += self.TAB + '/* No Outputs*/\n' + self.TAB + '\n\n'
        else:

            string += self.TAB + '//PYTHON - Digital write the outputs\n'
            for i, item in enumerate(self.outputs):
                string += self.TAB + 'digitalWrite(' + str(self.DIGITAL_PORTS[i + len(self.inputs)]) + ', place_out->' + item + ');\n'
            string += self.TAB + '//PYTHON - End digital write the outputs\n\n'
        return string

    def get_send_comm_string(self):
        string = self.TAB + 'if( events != NULL ) {\n'
        string += self.TAB + self.TAB + '//PYTHON - Send communication\n'
        for i in self.output_events:
            string += self.TAB + self.TAB + 'if (events->' + i+ ') {\n' +\
                      self.TAB + self.TAB + self.TAB + 'Wire.beginTransmission(I2C_ADDRESS_' + i + ');\n' + \
                      self.TAB + self.TAB + self.TAB + 'Wire.write("' + i + '");\n' + \
                      self.TAB + self.TAB + self.TAB + 'Wire.endTransmission();\n' + \
                      self.TAB + self.TAB + '}\n'
        string += self.TAB + self.TAB + '//PYTHON - End send communication\n' + self.TAB + '}\n\n'
        return string


    def ask_for_addresses(self):
        # This device address
        for k in self.output_events:
            for model in self.models:
                for e in model['events']:
                    if e == k:
                        self.addresses.append(
                            {
                                'address': model['address'],
                                'event'  : k
                            })
            #address = raw_input("Enter the address of " + k + " device: ")

        print 'Addresses'
        print self.addresses



    def get_file_data(self, file_content):
        '''
            Method to count the number of events in this net
            @param file_content content of the input file
            @return number of events in this net
        '''

        input_digital_string = re.findall(r'.InputSignalEvents(.*)input_fv != NULL.*', file_content, re.S)
        self.inputs = re.findall(r'inputs->(.*) = 0;', input_digital_string[0])
        print "\nInputs"
        for i, item in enumerate(self.inputs):
            print 'Digital ' + str(self.DIGITAL_PORTS[i]) + " -> " + item
        print len(self.inputs)

        #output events string
        output_events_string = re.findall(r'.OutputSignalEvents(.*)LoopDelay().*', file_content, re.S)
        self.outputs = re.findall(r'place_out->(.*) \*\/', output_events_string[0][0])
        print "\nOutputs: "
        for i, item in enumerate(self.outputs):
            print 'Digital ' + str(self.DIGITAL_PORTS[i + len(self.inputs)]) + " -> " + item
        print len(self.outputs)

        # input events string
        input_events_string = re.findall(r'.GetInputSignals\(.*events != NULL(.*)input_fv != NULL.*', file_content, re.S)
        print "\nInput Events: "
        if len(input_events_string) > 0:
            self.input_events = re.findall(r'events->(.*) \*\/', input_events_string[0])
        print self.input_events
        print len(self.input_events)

        print "\nOutput Events: "
        self.output_events = re.findall(r'events->(.*) \*\/', output_events_string[0][0])
        print self.output_events
        print len(self.output_events)

        self.model_name = re.findall(r'.starts: \*/\nvoid (.*)_InitializeIO().*', file_content, re.S)[0][0]

    @staticmethod
    def get_all_outputs(_file):
        f_read = open(_file, 'r')
        output_events_string = re.findall(r'.OutputSignalEvents(.*)LoopDelay().*', f_read.read(), re.S)
        outputs = re.findall(r'events->(.*) \*\/', output_events_string[0][0])
        f_read.close()
        return outputs